# 클로저

클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합.

### 렉시컬 환경

JavaScript에서 중요한 개념 중 하나로, 변수와 함수가 어디에서 정의되었는지에 따라 그 범위(scope)가 결정되는 방식입니다. 이를 통해 코드가 실행될 때 변수에 접근할 수 있는지 여부가 결정됩니다.

렉시컬 환경(Lexical Environment)

JavaScript 코드가 실행될 때 생성되는 내부적인 구조로, 해당 코드 블록 내에서 선언된 변수들과 상위 스코프 정보를 가지고 있습니다.
**환경 레코드(Environment Record)**와 **외부 렉시컬 환경 참조(Outer Lexical Environment Reference)**로 구성됩니다.

- 환경 레코드: 현재 범위(스코프)에서 선언된 변수, 함수 등의 정보를 기록하는 객체.
  외부 렉시컬 환경 참조: 상위 스코프를 참조하는 링크로, 이를 통해 외부의 렉시컬 환경에 정의된 변수와 함수에 접근할 수 있습니다.
  렉시컬 스코프(Lexical Scope):

- 코드가 작성된 위치에 따라 스코프가 결정됩니다. 즉, 함수가 어디에서 호출되었는지가 아니라 어디에서 선언되었는지가 중요합니다.
  함수 내부에서 변수에 접근할 때, 해당 변수가 현재 함수 내에 없으면 외부 렉시컬 환경을 따라가면서 변수를 찾습니다.

```
function outer() {
  let x = 10;
  function inner() {
    console.log(x);
  }
  inner();
}

outer();
```

outer 함수에 innter 함수가 중첩 함수로 선언되어 있는데 이때 inner 내부에서 자신을 포함하고 있는 외부 함수 outer의 x에 접근할 수 있다.

만약 inner 함수가 outer 함수 내부에 있지 않다면 inner 함수를 outer 함수 내부에서 호출해도 x의 값에 접근할 수 없다.

## 렉시컬 스코프

자바스크립트 엔진은 함수를 어디서 호출했는지가 중요한게 아니라 어디에 정의했는지에 따라 상위 스코프를 결정한다
이를 렉시컬 스코프(정적 스코프)라 한다.

```
const x = 1;

function foo() {
  const x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // ?
bar(); // ?

```

foo와 bar 함수가 호출 된 값을 유추해보는것도 좋을거 같습니다.

렉시컬 환경의 "외부 렉시컬 환경에 대한 참조"에 저장할 참조값, 즉 상위 스코프에 대한 참조는 함수 정의가 평가되는 시점에 함수가 정의된 환경(위치)에 의해 결정된다. 이것이 렉시컬 스코프다.

## 함수 객체의 내부 슬롯

함수는 자신의 내부 슬롯 [[Environment]]에 자신이 정의된 환경, 즉 상위 스코프의 참조를 저장한다.

함수 정의가 평가되어 함수 객체를 생성할 때 자신이 정의된 환경에 의해 결정된 상위 스코프의 참조를 함수 객체 자신의 내부 슬롯 [[Environment]]에 저장한다.

따라서 함수 객체의 내부 슬롯 [[Environment]]에 저장된 현재 실행 중인 실행 컨텍스트의 렉시컬 환경의 참조가 바로 상위 스코프다. 또한 자신이 호출되었을 때 생성될 함수 렉시컬 환경의 "외부 렉시컬 환경에 대한 참조"에 저장될 참조값이다. 함수 객체는 내부 슬롯[[Environment]]에 저장한 렉시컬 환경의 참조, 즉 상위 스코프를 자신이 존재하는 한 기억한다.

함수가 호출되면 함수 내부로 코드의 제어권이 이동한다. 그리고 함수 코드를 평가하기 시작한다. 함수 코드 평가는 아래 순서로 진행된다.

1. 함수 실행 컨텍스트 생성
2. 함수 렉시컬 환경 생성
   2.1 함수 환경 레코드 생성
   2.2 this 바인딩
   2.3 외부 렉시컬 환경에 대한 참조 결정

외부 렉시컬 환경에 대한 참조에는 함수 객체의 내부 슬롯[[Environment]]에 저장된 렉시컬 환경의 참조가 할당됨.

## 클로저와 렉시컬 환경

```
const x = 1;

//1번
function outer() {
  const x = 10;
  const inner = function () {
    console.log(x);
  }; //2번
  return inner;
}

const innerFunc = outer(); //3번

innerFunc(); //4번 10

```

outer 함수를 호출하면 outer 함수는 중첩 함수 inner 반환하고 생명 주기를 마감한다. 즉, outer 함수의 실행이 종료되면 outer 함수의 실행 컨텍스트는 실행 컨텍스트 스택에 제거 된다. 이때 outer 함수의 지역 변수 x와 변수 값 10을 저장하고 있던 outer 함수의 실행 컨텍스트가 제거되었으므로 outer 함수의 지역 변수 x 또한 생명 주기를 마감.

그러나 위 코드의 실행 결과는 outer 함수의 지역 변수 x의 값인 10이다.

<b>외부 함수보다 중첩 함수다 더 오래 유지되는 경우 중첩 함수는 이미 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있다. 이러한 중첩 함수를 클로저라고 한다.</b>

"그 함수가 선언된 렉시컬 환경"이란 함수가 정의된 위치의 스코프 즉, 상위 스코프를 의미하는 실행 컨텍스트의 렉시컬 환경을 말함.

자바스크립트의 모든 함수는 자신의 상위 스코프를 기억함. 모든 함수가 기억하는 상위 스코프는 함수를 어디서 호출하든 상관없이 유지. 따라서 함수를 어디서 호출하든 상관없이 함수는 언제나 자신이 기억하는 상위 소크프의 식별자를 참조할 수 있으며 식별자에 바인딩 된 값을 변경할 수 도 있다.

자바스크립트의 모든 함수는 상위 스코프를 기억하므로 이론적으로 모든 함수는 클로저다.
하지만 일반적으로 모든 함수를 클로저라고 하지 않는다.

```
function foo() {
  const x = 1;
  const y = 1;
  function bar() {
    const z = 3;
    console.log(z);
  }
  return bar;
}

const bar = foo();
bar();

```

위 코드처럼 bar 함수가 foo의 중첩 함수이지만 bar 함수에서 상위 스코프의 값인 x나 y의 값을 참조하지 않으므로 모던 브라우저에서는 최적화를 통해 상위 스코프를 기억하지 않는다.

클로저는 중첩 함수가 상위 스코프의 식별자를 참조하고 있고 중첩 함수가 외부 함수보다 더 오래 유지되는 경우에 한정하는 것이 일반적.
